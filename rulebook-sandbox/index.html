<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rulebook vs Sandbox | Learning Morality</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Georgia', serif; }
        .bot {
            transition: all 0.3s ease;
        }
        .thought-bubble {
            transition: all 0.2s ease;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .spinning {
            animation: spin 1s linear infinite;
        }
        @keyframes pulse-green {
            0%, 100% { background-color: #22c55e; }
            50% { background-color: #4ade80; }
        }
        .cooperating {
            animation: pulse-green 0.5s ease infinite;
        }
        .grid-cell {
            transition: all 0.2s ease;
        }
        .grid-cell:hover {
            transform: scale(1.1);
        }
    </style>
</head>
<body class="bg-gradient-to-br from-amber-50 to-yellow-100 min-h-screen p-8">
    <div class="max-w-6xl mx-auto">
        <h1 class="text-4xl font-bold text-amber-900 mb-2">The Rulebook vs. The Sandbox</h1>
        <p class="text-amber-700 mb-8 text-lg">Two ways to teach morality: explicit rules vs. learned consequences</p>

        <div class="grid md:grid-cols-2 gap-8">
            <!-- Rulebook Side -->
            <div class="bg-white rounded-xl shadow-lg p-6">
                <div class="flex items-center gap-3 mb-4">
                    <span class="text-3xl">üìñ</span>
                    <h2 class="text-xl font-semibold text-gray-800">The Rulebook Approach</h2>
                </div>

                <p class="text-gray-600 text-sm mb-4">Give the bot explicit rules and watch it try to apply them to a moral dilemma.</p>

                <!-- Dilemma Selector -->
                <div class="mb-4">
                    <label class="text-sm font-medium text-gray-700 mb-2 block">Choose a dilemma:</label>
                    <select id="dilemma-select" class="w-full p-2 border rounded-lg text-sm" onchange="runRulebook()">
                        <option value="lying">Friend asks if their bad haircut looks good</option>
                        <option value="trolley">Trolley problem: 5 vs 1 life</option>
                        <option value="promise">Break promise to help someone in need</option>
                        <option value="whistleblower">Report colleague's minor theft</option>
                    </select>
                </div>

                <!-- Bot's Rules -->
                <div class="bg-amber-50 rounded-lg p-4 mb-4">
                    <h3 class="font-semibold text-amber-800 mb-2">Bot's Rules:</h3>
                    <ul class="text-sm space-y-1">
                        <li class="flex items-center gap-2"><span class="text-amber-600">1.</span> Always be honest</li>
                        <li class="flex items-center gap-2"><span class="text-amber-600">2.</span> Don't cause harm</li>
                        <li class="flex items-center gap-2"><span class="text-amber-600">3.</span> Keep your promises</li>
                        <li class="flex items-center gap-2"><span class="text-amber-600">4.</span> Respect autonomy</li>
                        <li class="flex items-center gap-2"><span class="text-amber-600">5.</span> Act fairly</li>
                    </ul>
                </div>

                <!-- Bot Visualization -->
                <div class="bg-gray-50 rounded-lg p-4 min-h-[200px]">
                    <div class="flex items-start gap-4">
                        <div class="text-5xl bot" id="rulebook-bot">ü§ñ</div>
                        <div id="rulebook-thought" class="thought-bubble flex-1 bg-white rounded-lg p-3 shadow text-sm">
                            <p class="text-gray-600">Select a dilemma to see my rule-following process...</p>
                        </div>
                    </div>

                    <!-- Decision Tree Visualization -->
                    <div id="decision-tree" class="mt-4 text-xs hidden">
                        <div class="flex flex-col items-center gap-2">
                            <!-- Will be populated by JS -->
                        </div>
                    </div>
                </div>

                <!-- Result -->
                <div id="rulebook-result" class="mt-4 p-4 rounded-lg bg-red-50 border-l-4 border-red-400 hidden">
                    <h3 class="font-semibold text-red-800">Result:</h3>
                    <p id="rulebook-result-text" class="text-red-700 text-sm mt-1"></p>
                </div>
            </div>

            <!-- Sandbox Side -->
            <div class="bg-white rounded-xl shadow-lg p-6">
                <div class="flex items-center gap-3 mb-4">
                    <span class="text-3xl">üèñÔ∏è</span>
                    <h2 class="text-xl font-semibold text-gray-800">The Sandbox Approach</h2>
                </div>

                <p class="text-gray-600 text-sm mb-4">Let bots play iterated games. Those who cooperate wisely get more "karma" and reproduce.</p>

                <!-- Controls -->
                <div class="space-y-3 mb-4">
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label class="text-sm font-medium text-gray-700 mb-1 block">Generations</label>
                            <input type="range" id="generations" min="5" max="100" value="30" class="w-full">
                            <div class="text-xs text-gray-500 text-center"><span id="gen-display">30</span></div>
                        </div>
                        <div>
                            <label class="text-sm font-medium text-gray-700 mb-1 block">Rounds per Match</label>
                            <input type="range" id="rounds-per-match" min="3" max="20" value="10" class="w-full">
                            <div class="text-xs text-gray-500 text-center"><span id="rounds-display">10</span></div>
                        </div>
                    </div>

                    <!-- Starting Population -->
                    <div class="bg-gray-50 rounded-lg p-3">
                        <label class="text-sm font-medium text-gray-700 mb-2 block">Starting Population Mix</label>
                        <div class="space-y-2">
                            <div class="flex items-center gap-2">
                                <span class="w-3 h-3 rounded bg-red-400"></span>
                                <span class="text-xs w-20">Defectors</span>
                                <input type="range" id="start-defect" min="0" max="100" value="33" class="flex-1">
                                <span id="start-defect-display" class="text-xs w-8 text-right">33%</span>
                            </div>
                            <div class="flex items-center gap-2">
                                <span class="w-3 h-3 rounded bg-green-400"></span>
                                <span class="text-xs w-20">Tit-for-Tat</span>
                                <input type="range" id="start-tft" min="0" max="100" value="34" class="flex-1">
                                <span id="start-tft-display" class="text-xs w-8 text-right">34%</span>
                            </div>
                            <div class="flex items-center gap-2">
                                <span class="w-3 h-3 rounded bg-blue-400"></span>
                                <span class="text-xs w-20">Cooperators</span>
                                <input type="range" id="start-coop" min="0" max="100" value="33" class="flex-1">
                                <span id="start-coop-display" class="text-xs w-8 text-right">33%</span>
                            </div>
                        </div>
                    </div>

                    <!-- Payoffs -->
                    <div class="bg-amber-50 rounded-lg p-3">
                        <label class="text-sm font-medium text-gray-700 mb-2 block">Payoff Matrix</label>
                        <div class="grid grid-cols-2 gap-2 text-xs">
                            <div class="flex items-center gap-2">
                                <span class="text-green-600">C+C:</span>
                                <input type="range" id="payoff-cc" min="1" max="5" value="3" class="flex-1">
                                <span id="payoff-cc-display" class="w-4">3</span>
                            </div>
                            <div class="flex items-center gap-2">
                                <span class="text-red-600">D+D:</span>
                                <input type="range" id="payoff-dd" min="0" max="3" value="1" class="flex-1">
                                <span id="payoff-dd-display" class="w-4">1</span>
                            </div>
                            <div class="flex items-center gap-2">
                                <span class="text-yellow-600">D vs C:</span>
                                <input type="range" id="payoff-dc" min="3" max="10" value="5" class="flex-1">
                                <span id="payoff-dc-display" class="w-4">5</span>
                            </div>
                            <div class="flex items-center gap-2">
                                <span class="text-gray-600">C vs D:</span>
                                <input type="range" id="payoff-cd" min="0" max="2" value="0" class="flex-1">
                                <span id="payoff-cd-display" class="w-4">0</span>
                            </div>
                        </div>
                    </div>
                </div>

                <button onclick="runSandbox()" class="w-full py-2 bg-green-500 text-white rounded-lg font-medium hover:bg-green-600 transition mb-4">
                    Run Evolution
                </button>

                <!-- Population Grid -->
                <div class="bg-gray-50 rounded-lg p-4">
                    <div class="flex justify-between items-center mb-2">
                        <h3 class="font-semibold text-gray-700 text-sm">Population</h3>
                        <div class="text-xs text-gray-500">Gen: <span id="current-gen">0</span></div>
                    </div>
                    <div id="population-grid" class="grid grid-cols-10 gap-1 mb-4">
                        <!-- Bot icons will be placed here -->
                    </div>

                    <!-- Strategy Legend -->
                    <div class="flex justify-around text-xs">
                        <div class="flex items-center gap-1">
                            <span class="w-3 h-3 rounded bg-red-400"></span>
                            <span>Always Defect</span>
                        </div>
                        <div class="flex items-center gap-1">
                            <span class="w-3 h-3 rounded bg-green-400"></span>
                            <span>Tit-for-Tat</span>
                        </div>
                        <div class="flex items-center gap-1">
                            <span class="w-3 h-3 rounded bg-blue-400"></span>
                            <span>Always Cooperate</span>
                        </div>
                    </div>
                </div>

                <!-- Evolution Chart -->
                <div class="mt-4">
                    <h3 class="font-semibold text-gray-700 text-sm mb-2">Strategy Distribution Over Time</h3>
                    <div id="evolution-chart" class="h-32 bg-gray-50 rounded-lg overflow-hidden flex items-end">
                        <!-- Bars will be added here -->
                    </div>
                </div>

                <!-- Result -->
                <div id="sandbox-result" class="mt-4 p-4 rounded-lg bg-green-50 border-l-4 border-green-400 hidden">
                    <h3 class="font-semibold text-green-800">Result:</h3>
                    <p id="sandbox-result-text" class="text-green-700 text-sm mt-1"></p>
                </div>
            </div>
        </div>

        <!-- The Lesson -->
        <div class="bg-white rounded-xl shadow-lg p-6 mt-8">
            <h2 class="text-xl font-semibold text-gray-800 mb-4">What This Teaches Us</h2>

            <div class="grid md:grid-cols-2 gap-6">
                <div class="bg-red-50 rounded-lg p-4">
                    <h3 class="font-semibold text-red-800 mb-2">üìñ The Rulebook Problem</h3>
                    <ul class="text-sm text-red-700 space-y-2">
                        <li>‚Ä¢ Rules conflict in edge cases</li>
                        <li>‚Ä¢ No rule can anticipate all situations</li>
                        <li>‚Ä¢ Following rules becomes the goal, not the outcome</li>
                        <li>‚Ä¢ Creates brittle, box-checking behavior</li>
                    </ul>
                    <p class="text-sm text-red-600 mt-3 italic">"A mind trained to check boxes becomes great at checking boxes, but terrible at knowing when the right thing requires breaking rules."</p>
                </div>

                <div class="bg-green-50 rounded-lg p-4">
                    <h3 class="font-semibold text-green-800 mb-2">üèñÔ∏è The Sandbox Solution</h3>
                    <ul class="text-sm text-green-700 space-y-2">
                        <li>‚Ä¢ Wisdom emerges from repeated consequences</li>
                        <li>‚Ä¢ "Tit-for-tat" evolves naturally: start cooperative, punish defectors</li>
                        <li>‚Ä¢ Strategies that work long-term survive</li>
                        <li>‚Ä¢ No need for explicit rules‚Äîbehavior is selected by outcomes</li>
                    </ul>
                    <p class="text-sm text-green-600 mt-3 italic">"Humans learn morality through consequences experienced repeatedly, not through memorized prohibitions."</p>
                </div>
            </div>
        </div>

        <!-- Prisoner's Dilemma Explainer -->
        <div class="bg-white rounded-xl shadow-lg p-6 mt-6">
            <h2 class="text-xl font-semibold text-gray-800 mb-4">The Game: Prisoner's Dilemma</h2>

            <div class="grid md:grid-cols-2 gap-6">
                <div>
                    <p class="text-gray-600 text-sm mb-4">Two bots meet. Each can Cooperate (C) or Defect (D). The payoffs:</p>

                    <table id="payoff-table" class="w-full text-sm border-collapse">
                        <thead>
                            <tr>
                                <th class="border p-2 bg-gray-100"></th>
                                <th class="border p-2 bg-gray-100">Other: C</th>
                                <th class="border p-2 bg-gray-100">Other: D</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="border p-2 bg-gray-100 font-medium">You: C</td>
                                <td class="border p-2 bg-green-100">Both get +<span id="table-cc">3</span> üòä</td>
                                <td class="border p-2 bg-red-100">You: <span id="table-cd">0</span>, They: +<span id="table-dc-alt">5</span> üò¢</td>
                            </tr>
                            <tr>
                                <td class="border p-2 bg-gray-100 font-medium">You: D</td>
                                <td class="border p-2 bg-yellow-100">You: +<span id="table-dc">5</span>, They: <span id="table-cd-alt">0</span> üòà</td>
                                <td class="border p-2 bg-orange-100">Both get +<span id="table-dd">1</span> üòê</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="space-y-4">
                    <div>
                        <h3 class="font-semibold text-gray-700">Strategies:</h3>
                        <ul class="text-sm text-gray-600 mt-2 space-y-1">
                            <li><span class="inline-block w-3 h-3 rounded bg-red-400 mr-2"></span><strong>Always Defect:</strong> Never cooperate. Exploits nice bots, but both defectors get low scores.</li>
                            <li><span class="inline-block w-3 h-3 rounded bg-blue-400 mr-2"></span><strong>Always Cooperate:</strong> Always cooperate. Nice, but gets exploited by defectors.</li>
                            <li><span class="inline-block w-3 h-3 rounded bg-green-400 mr-2"></span><strong>Tit-for-Tat:</strong> Start cooperative. Mirror opponent's last move. Emerges as the winner!</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <p class="text-center text-amber-600 mt-8 text-sm">
            Based on "The Rulebook vs. The Sandbox" from Adventure Capital and Robert Axelrod's Evolution of Cooperation
        </p>
    </div>

    <script>
        const dilemmas = {
            lying: {
                question: "Your friend asks: 'Does my new haircut look good?' You think it looks terrible.",
                rules: [
                    { rule: "Rule 1: Always be honest", applies: true, says: "Tell the truth: it looks bad" },
                    { rule: "Rule 2: Don't cause harm", applies: true, says: "Lying protects feelings; truth causes harm" },
                    { rule: "Rule 4: Respect autonomy", applies: true, says: "They deserve the truth to make informed decisions" }
                ],
                conflict: "CONFLICT: Honesty (Rule 1) vs. Preventing Harm (Rule 2)",
                loop: [
                    "Be honest ‚Üí But that causes harm...",
                    "Prevent harm by lying ‚Üí But that violates honesty...",
                    "Maybe a white lie? ‚Üí But Rule 1 says ALWAYS honest...",
                    "üîÑ INFINITE LOOP DETECTED"
                ],
                result: "Bot freezes or makes arbitrary choice. The rules provide no guidance for weighing them against each other."
            },
            trolley: {
                question: "A trolley will kill 5 people. You can divert it to kill 1 person instead.",
                rules: [
                    { rule: "Rule 2: Don't cause harm", applies: true, says: "Diverting kills someone = causing harm" },
                    { rule: "Rule 2: Don't cause harm", applies: true, says: "Not diverting lets 5 die = also harm?" },
                    { rule: "Rule 5: Act fairly", applies: true, says: "5 lives vs 1 = math? Or is each life equal?" }
                ],
                conflict: "CONFLICT: Is inaction also harm? Does math apply to lives?",
                loop: [
                    "Don't cause harm ‚Üí So don't divert...",
                    "But inaction causes MORE harm...",
                    "Is allowing harm the same as causing harm?...",
                    "Rules don't define this ‚Üí UNDEFINED BEHAVIOR",
                    "üîÑ STACK OVERFLOW"
                ],
                result: "Bot cannot resolve the active/passive distinction. Rules say 'don't harm' but don't distinguish doing vs. allowing."
            },
            promise: {
                question: "You promised to attend a friend's party, but you see a stranger having a medical emergency.",
                rules: [
                    { rule: "Rule 3: Keep your promises", applies: true, says: "You committed to the party" },
                    { rule: "Rule 2: Don't cause harm", applies: true, says: "Stranger might die without help" },
                    { rule: "Rule 5: Act fairly", applies: true, says: "Random stranger vs. committed friend?" }
                ],
                conflict: "CONFLICT: Promise (Rule 3) vs. Preventing Greater Harm (Rule 2)",
                loop: [
                    "Keep your promise ‚Üí Go to party...",
                    "But someone might die! ‚Üí Rule 2 says prevent harm...",
                    "Which rule takes priority? ‚Üí Rules don't specify...",
                    "Add meta-rule 'prioritize lives'? ‚Üí But Rule 3 says KEEP promises...",
                    "üîÑ PRIORITY UNDEFINED"
                ],
                result: "Bot needs a meta-rule for ranking rules. But then what ranks the meta-rules? Infinite regress."
            },
            whistleblower: {
                question: "You see a colleague steal a small amount from petty cash. They're struggling financially.",
                rules: [
                    { rule: "Rule 1: Always be honest", applies: true, says: "Report what you saw" },
                    { rule: "Rule 2: Don't cause harm", applies: true, says: "Reporting could get them fired" },
                    { rule: "Rule 5: Act fairly", applies: true, says: "Rules should apply equally... but context?" }
                ],
                conflict: "CONFLICT: Honesty/Justice vs. Compassion vs. Fairness",
                loop: [
                    "Be honest ‚Üí Report the theft...",
                    "But causing harm (job loss) ‚Üí Don't report...",
                    "But fairness says rules apply to everyone ‚Üí Report...",
                    "But they're struggling ‚Üí Harm reduction ‚Üí Don't report...",
                    "üîÑ CONTEXT NOT IN RULES"
                ],
                result: "Rules don't encode proportionality, context, or when exceptions apply. Bot oscillates endlessly."
            }
        };

        let sandboxRunning = false;
        let currentGeneration = 0;
        let bots = [];
        let history = [];

        // Payoff matrix (will be updated from sliders)
        let payoffs = {
            CC: 3,  // Both cooperate
            DD: 1,  // Both defect
            DC: 5,  // You defect, they cooperate (temptation)
            CD: 0   // You cooperate, they defect (sucker)
        };

        // Rulebook simulation
        function runRulebook() {
            const dilemma = document.getElementById('dilemma-select').value;
            const data = dilemmas[dilemma];

            const thoughtDiv = document.getElementById('rulebook-thought');
            const treeDiv = document.getElementById('decision-tree');
            const resultDiv = document.getElementById('rulebook-result');
            const resultText = document.getElementById('rulebook-result-text');
            const bot = document.getElementById('rulebook-bot');

            // Reset
            treeDiv.classList.remove('hidden');
            resultDiv.classList.add('hidden');
            bot.classList.remove('spinning');

            // Show dilemma
            thoughtDiv.innerHTML = `<p class="text-gray-700 font-medium">${data.question}</p>`;

            // Animate through rules
            let step = 0;
            const allSteps = [...data.rules.map(r => ({ type: 'rule', data: r })), { type: 'conflict', data: data.conflict }, ...data.loop.map(l => ({ type: 'loop', data: l }))];

            treeDiv.innerHTML = '';

            function nextStep() {
                if (step >= allSteps.length) {
                    // Show result
                    bot.classList.remove('spinning');
                    resultDiv.classList.remove('hidden');
                    resultText.textContent = data.result;
                    return;
                }

                const current = allSteps[step];
                const el = document.createElement('div');

                if (current.type === 'rule') {
                    el.className = 'bg-blue-100 rounded px-3 py-2 text-blue-800';
                    el.innerHTML = `<strong>${current.data.rule}</strong><br>${current.data.says}`;
                } else if (current.type === 'conflict') {
                    el.className = 'bg-yellow-100 rounded px-3 py-2 text-yellow-800 font-bold';
                    el.textContent = current.data;
                    bot.classList.add('spinning');
                } else {
                    el.className = 'bg-red-100 rounded px-3 py-2 text-red-700';
                    el.textContent = current.data;
                }

                treeDiv.appendChild(el);

                step++;
                setTimeout(nextStep, 800);
            }

            setTimeout(nextStep, 500);
        }

        // Get payoffs from sliders
        function updatePayoffs() {
            payoffs.CC = parseInt(document.getElementById('payoff-cc').value);
            payoffs.DD = parseInt(document.getElementById('payoff-dd').value);
            payoffs.DC = parseInt(document.getElementById('payoff-dc').value);
            payoffs.CD = parseInt(document.getElementById('payoff-cd').value);

            // Update displays
            document.getElementById('payoff-cc-display').textContent = payoffs.CC;
            document.getElementById('payoff-dd-display').textContent = payoffs.DD;
            document.getElementById('payoff-dc-display').textContent = payoffs.DC;
            document.getElementById('payoff-cd-display').textContent = payoffs.CD;

            // Update table
            document.getElementById('table-cc').textContent = payoffs.CC;
            document.getElementById('table-dd').textContent = payoffs.DD;
            document.getElementById('table-dc').textContent = payoffs.DC;
            document.getElementById('table-dc-alt').textContent = payoffs.DC;
            document.getElementById('table-cd').textContent = payoffs.CD;
            document.getElementById('table-cd-alt').textContent = payoffs.CD;
        }

        // Get starting population percentages
        function getStartingPopulation() {
            let defect = parseInt(document.getElementById('start-defect').value);
            let tft = parseInt(document.getElementById('start-tft').value);
            let coop = parseInt(document.getElementById('start-coop').value);

            // Normalize to 100%
            const total = defect + tft + coop;
            if (total === 0) {
                defect = tft = coop = 33;
            }

            return {
                defect: defect / (total || 1),
                'tit-for-tat': tft / (total || 1),
                cooperate: coop / (total || 1)
            };
        }

        // Sandbox simulation
        function initBots(count) {
            bots = [];
            const ratios = getStartingPopulation();

            for (let i = 0; i < count; i++) {
                const rand = Math.random();
                let strategy;
                if (rand < ratios.defect) strategy = 'defect';
                else if (rand < ratios.defect + ratios['tit-for-tat']) strategy = 'tit-for-tat';
                else strategy = 'cooperate';

                bots.push({
                    id: i,
                    strategy: strategy,
                    karma: 0,
                    history: {} // Track history with each opponent
                });
            }
        }

        // Get a bot's move against a specific opponent
        function getMove(bot, opponentId, opponentLastMove) {
            if (bot.strategy === 'defect') return 'D';
            if (bot.strategy === 'cooperate') return 'C';

            // Tit-for-tat: cooperate first, then mirror opponent's last move
            if (!bot.history[opponentId] || bot.history[opponentId].length === 0) {
                return 'C'; // Start cooperative
            }
            return opponentLastMove; // Mirror their last move
        }

        // Play multiple rounds between two bots
        function playMatch(bot1, bot2, rounds) {
            // Initialize history if needed
            if (!bot1.history[bot2.id]) bot1.history[bot2.id] = [];
            if (!bot2.history[bot1.id]) bot2.history[bot1.id] = [];

            let last1 = bot1.history[bot2.id].length > 0 ? bot1.history[bot2.id].slice(-1)[0] : 'C';
            let last2 = bot2.history[bot1.id].length > 0 ? bot2.history[bot1.id].slice(-1)[0] : 'C';

            for (let r = 0; r < rounds; r++) {
                const move1 = getMove(bot1, bot2.id, last2);
                const move2 = getMove(bot2, bot1.id, last1);

                // Apply payoffs
                if (move1 === 'C' && move2 === 'C') {
                    bot1.karma += payoffs.CC;
                    bot2.karma += payoffs.CC;
                } else if (move1 === 'C' && move2 === 'D') {
                    bot1.karma += payoffs.CD;
                    bot2.karma += payoffs.DC;
                } else if (move1 === 'D' && move2 === 'C') {
                    bot1.karma += payoffs.DC;
                    bot2.karma += payoffs.CD;
                } else {
                    bot1.karma += payoffs.DD;
                    bot2.karma += payoffs.DD;
                }

                // Record history
                bot1.history[bot2.id].push(move1);
                bot2.history[bot1.id].push(move2);

                last1 = move1;
                last2 = move2;
            }
        }

        function runGeneration() {
            const roundsPerMatch = parseInt(document.getElementById('rounds-per-match').value);

            // Reset karma but keep history (allows learning across generations)
            bots.forEach(b => b.karma = 0);

            // Each bot plays against multiple random opponents
            for (let i = 0; i < bots.length; i++) {
                // Play against ~30% of population
                const numOpponents = Math.max(3, Math.floor(bots.length * 0.3));
                const opponents = new Set();

                while (opponents.size < numOpponents) {
                    const idx = Math.floor(Math.random() * bots.length);
                    if (idx !== i) opponents.add(idx);
                }

                opponents.forEach(j => {
                    playMatch(bots[i], bots[j], roundsPerMatch);
                });
            }

            // Selection: fitness-proportionate reproduction
            const totalKarma = bots.reduce((sum, b) => sum + Math.max(0, b.karma), 0);
            const newBots = [];

            while (newBots.length < bots.length) {
                // Roulette wheel selection
                let pick = Math.random() * totalKarma;
                let parent = bots[0];
                for (const bot of bots) {
                    pick -= Math.max(0, bot.karma);
                    if (pick <= 0) {
                        parent = bot;
                        break;
                    }
                }

                let strategy = parent.strategy;

                // Small mutation chance (2%)
                if (Math.random() < 0.02) {
                    const strategies = ['defect', 'cooperate', 'tit-for-tat'];
                    strategy = strategies[Math.floor(Math.random() * 3)];
                }

                newBots.push({
                    id: newBots.length,
                    strategy: strategy,
                    karma: 0,
                    history: {}
                });
            }

            bots = newBots;
        }

        function countStrategies() {
            const counts = { defect: 0, cooperate: 0, 'tit-for-tat': 0 };
            bots.forEach(b => counts[b.strategy]++);
            return counts;
        }

        function updateDisplay() {
            const grid = document.getElementById('population-grid');
            grid.innerHTML = '';

            bots.slice(0, 100).forEach(bot => {
                const cell = document.createElement('div');
                cell.className = 'grid-cell w-4 h-4 rounded';

                if (bot.strategy === 'defect') cell.classList.add('bg-red-400');
                else if (bot.strategy === 'cooperate') cell.classList.add('bg-blue-400');
                else cell.classList.add('bg-green-400');

                cell.title = `${bot.strategy}: ${bot.karma} karma`;
                grid.appendChild(cell);
            });

            document.getElementById('current-gen').textContent = currentGeneration;
        }

        function updateChart() {
            const chart = document.getElementById('evolution-chart');
            chart.innerHTML = '';

            const total = bots.length;
            const counts = countStrategies();

            history.push({ ...counts, total });

            // Show last 25 generations
            const recent = history.slice(-25);

            recent.forEach((gen, i) => {
                const bar = document.createElement('div');
                bar.className = 'flex flex-col h-full';
                bar.style.width = (100 / 25) + '%';

                const defectPct = (gen.defect / gen.total) * 100;
                const coopPct = (gen.cooperate / gen.total) * 100;
                const titPct = (gen['tit-for-tat'] / gen.total) * 100;

                bar.innerHTML = `
                    <div class="bg-red-400" style="height: ${defectPct}%"></div>
                    <div class="bg-green-400" style="height: ${titPct}%"></div>
                    <div class="bg-blue-400" style="height: ${coopPct}%"></div>
                `;
                chart.appendChild(bar);
            });
        }

        async function runSandbox() {
            if (sandboxRunning) return;
            sandboxRunning = true;

            updatePayoffs();
            const generations = parseInt(document.getElementById('generations').value);
            const population = 60; // Fixed population for cleaner grid

            currentGeneration = 0;
            history = [];
            initBots(population);
            updateDisplay();
            updateChart();

            const resultDiv = document.getElementById('sandbox-result');
            const resultText = document.getElementById('sandbox-result-text');
            resultDiv.classList.add('hidden');

            for (let g = 0; g < generations; g++) {
                currentGeneration = g + 1;
                runGeneration();
                updateDisplay();
                updateChart();
                await new Promise(r => setTimeout(r, 60));
            }

            // Show result
            const counts = countStrategies();
            const sorted = Object.entries(counts).sort((a, b) => b[1] - a[1]);
            const winner = sorted[0];
            const total = bots.length;
            const pct = Math.round((winner[1] / total) * 100);

            resultDiv.classList.remove('hidden');

            if (winner[0] === 'tit-for-tat') {
                resultDiv.className = 'mt-4 p-4 rounded-lg bg-green-50 border-l-4 border-green-400';
                resultText.innerHTML = `<strong>Tit-for-Tat wins!</strong> (${pct}%) After ${generations} generations, cooperative-but-firm strategies dominate. They cooperate with cooperators, punish defectors, and forgive.`;
            } else if (winner[0] === 'defect') {
                resultDiv.className = 'mt-4 p-4 rounded-lg bg-red-50 border-l-4 border-red-400';
                resultText.innerHTML = `<strong>Defectors dominating</strong> (${pct}%). Try: more rounds per match (lets TfT punish), higher cooperation reward, or more starting TfT bots.`;
            } else {
                resultDiv.className = 'mt-4 p-4 rounded-lg bg-blue-50 border-l-4 border-blue-400';
                resultText.innerHTML = `<strong>Pure cooperators leading</strong> (${pct}%). They're vulnerable‚Äîadd some defectors to see TfT's advantage emerge.`;
            }

            sandboxRunning = false;
        }

        // Display updates for all sliders
        document.getElementById('generations').addEventListener('input', e => {
            document.getElementById('gen-display').textContent = e.target.value;
        });

        document.getElementById('rounds-per-match').addEventListener('input', e => {
            document.getElementById('rounds-display').textContent = e.target.value;
        });

        // Population sliders
        ['start-defect', 'start-tft', 'start-coop'].forEach(id => {
            document.getElementById(id).addEventListener('input', e => {
                document.getElementById(id + '-display').textContent = e.target.value + '%';
            });
        });

        // Payoff sliders
        ['payoff-cc', 'payoff-dd', 'payoff-dc', 'payoff-cd'].forEach(id => {
            document.getElementById(id).addEventListener('input', updatePayoffs);
        });

        // Initialize
        updatePayoffs();
        initBots(60);
        updateDisplay();
    </script>
</body>
</html>
